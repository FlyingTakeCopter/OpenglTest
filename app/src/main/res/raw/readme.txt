第五章 Martix
单位矩阵：
1   0   0   0
0   1   0   0
0   0   1   0
0   0   0   1
单位矩阵乘以任何向量总是得到与原来相同的向量
1   0   0   0       1       1*1 + 0*2 + 0*3 + 0*4       1
0   1   0   0   *   2   =   0*1 + 1*2 + 0*3 + 0*4   =   2
0   0   1   0       3       0*1 + 0*2 + 1*3 + 0*4       3
0   0   0   1       4       0*1 + 0*2 + 0*3 + 1*4       4

平移矩阵
1   0   0   x
0   1   0   y
0   0   1   z
0   0   0   1
(2,2) X平移3，Y平移3
1   0   0   3       2       1*2 + 0*2 + 0*0 + 3*1       5
0   1   0   3   *   2   =   0*2 + 1*2 + 0*0 + 3*1   =   5
0   0   1   0       0       0*2 + 0*2 + 1*0 + 0*1       0
0   0   0   1       1       0*2 + 0*2 + 0*0 + 1*1       1

正交投影    android.opengl.Matrix   orthoM()
orthoM(float[] m, int mOffset, float left, float right, float bottom, float top, float near, float far)
float[] m:目标数组，这个数组的长度至少有16个元素，这样才能存储正交投影矩阵
int mOffet: 结果矩阵起始的偏移值
float left: x min
float right: x max
float bottom: y min
float top: y max
float near: z min
float near: z max

2/(right - left)            0                   0               (right + left) / (right - left)
        0           2 / (top - bottom)          0               (top + bottom) / (top - bottom)
        0                   0               2 / (far - near)    (far + near) / (far - near)
        0                   0                   0                           1

左手坐标与右手坐标
opengl使用右手坐标    远处z为负，近处z为正
gl_Position = u_Matrix * a_Postion
顶点数组a_Position不必被翻译为归一化设备坐标，而是理解为存在这个矩阵所定义的虚拟空间坐标中
这个矩阵会把坐标从虚拟坐标空间变换回归一化设备坐标

第六章 3D
6.1 从着色器到屏幕坐标的变换：
gl_Position          归一化设备坐标           窗口坐标
————————————》透视除法——————————————》视口变换————————————》

6.2.1 剪裁空间：
x   坐标
y   坐标
z   坐标
w   剪裁空间:对于任何给定位置，它的x、y、z分量都需要在那个位置的-w ~ +w之间。
比如一个位置的w是1，那么其x、y、z分量都要在-1 ~ +1之间
任何在剪裁空间之外的事物在屏幕上都是不可见的

6.2.2 透视除法：
在顶点位置成为一个归一化坐标之前，opengl实际上执行了一个透视除法的步骤。
透视除法之后保证每一个可是坐标取值范围都在 [-1，+1] 之间
为了在屏幕上创建三维的幻想，OpenGL会把每个gl_Position的x、y、z分量都除以它的分量w
当w分量用来表示距离的时候，就使得交院的物体被移动到距离渲染区域中心更近的地方，这个中心的作用就像是一个消失点
想象一副公路在远处越来越窄的画面，远处看不到的公路尽头，在画面中心
假设一个物体，他有两个顶点，每个顶点都在三维空间中的同一个位置，他们有同样的x,y,z，但w分量不同
          （1,1,1,1）       （1,1,1,2）
透视除法  （1/1,1/1,1/1）   （1/2,1/2,1/2）
            (1,1,1)        (0.5,0.5,0.5)
              近                 远
w值越大的坐标被移动到距离消失点(0,0,0)更近的位置

同质化坐标：因为透视除法，剪裁空间中的坐标经常被称为同质化坐标。
被称为同质化的原因是因为剪裁空间中的几个坐标可以映射到同一个点，例如:
(1,1,1,1)   (2,2,2,2)   (3,3,3,3)   (4,4,4,4)   (5,5,5,5)
透视除法后，这些所有点都映射到归一化设备坐标中的(1,1,1)

6.2.3 视口变换
这些被映射的坐标称为窗口坐标
onSurfaceChanged()中的glViewport()用来给OpenGL设置视口

6.4 透视投影
视椎体:是一个立方体，远端比近端大，从而使其变成一个被截断的金字塔。两端的大小差别越大，观察的范围越宽，我们能看到的也越多
视椎体焦点:顺着从视椎体较大端向较小端扩展出来的那些直线，一直向前通过较小端直到他们汇聚到一起。
当使用透视投影观察一个场景的时候，那个场景看上去就像是你的头被放在了焦点处。
焦点和视椎体小端的距离被称为焦距，焦距影响视椎体小端和大端的比例，以及其对应的视野

6.5 定义透视投影
对宽高比和视野进行调整
一个通用的投影矩阵，它允许我们调整视野以及屏幕的宽高比:
a/aspect            0               0                   0
    0               a               0                   0
    0               0      -(f + n) / (f - n)      2fn / (f - n)
    0               0               -1                  0
a: 想象一个相机拍摄的场景，这个变量就代表那个相机的焦距。焦距是由 1 / tan( 视野角度 / 2 ) 计算得到的，视野角度<180
aspect: 屏幕宽高比，宽度 / 高度
f: 到远处平面的距离，必须是正数且大于到最近处平面的距离
n: 到近处平面的距离，必须是正数。如果此值被设为1，那么近处平面就位于一个z值为-1处

随着视野变小，焦距边长，可以映射到归一化坐标中[-1,1]范围内的x和y值得范围就越小。这会产生使视椎体变窄的效果

6.7 开始使用投影矩阵
// 创建45度透视投影，这个视椎体从Z值为-1位置开始到z值为-10位置结束
MatrixHelper.perspectiveM(projectionMatrix, 45,
        (float)width / (float)height, 1f, 10f);
// 由于没有设置Z值所以Z默认为0，但是当前视椎体从-1开始，
// 由于物体不在视椎体中，所以无法显示

// 创建平移矩阵
Matrix.setIdentityM(modelMatrix, 0);    // 初始化单位矩阵
Matrix.translateM(modelMatrix, 0, 0f, 0f, -2f); // 沿Z轴平移-2

相乘一次还是相乘两次
两次：为了让每个顶点都移动到45度投影矩阵中，我们要先将平移矩阵应用于每个顶点，在将45度投影矩阵应用于每个顶点
一次：更简单方法是，我们让 45度投影矩阵 与 平移矩阵 相乘，得到新的矩阵再应用到顶点着色器。通过这种方式我们就可以在着色器中仅保留一个矩阵

矩阵乘法顺序，顺序不同导致结果不同
选择适当的顺序，
只使用投影矩阵: vertex_clip = ProjectionMatrix * vertex_eye(场景中的顶点在与投影矩阵相乘之前的位置)
加入平移矩阵:  vertex_eye = ModelMatrix * vertex_model(顶点在被模型矩阵放进场景中之前的位置)
             vertex_clip = ProjectionMatrix * vertex_eye

最终:         vertex_clip = ProjectionMatrix * ModelMatrix * vertex_model

6.8 旋转矩阵
以X为轴的旋转矩阵:
1           0           0           0
0         cos(a)      -sin(a)       0
0         sin(a)      cos(a)        0
0           0           0           1
以Y为轴:
cos(a)      0         sin(a)        0
0           1           0           0
-sin(a)     0         cos(a)        0
0           0           0           1
以Z为轴:
cos(a)    -sin(a)       0           0
sin(a)    cos(a)        0           0
0           0           1           0
0           0           0           1

举例 (0,1,0)以X轴旋转90度:
1       0       0       0       0       0
0    cos(90)  -sin(90)  0   *   1   =   0
0    sin(90)  cos(90)   0       0       1
0       0       0       1       1       1

(0,1,0)以X轴旋转90度结果为(0,0,1)

7.1 理解纹理
每个二维的纹理都有其自己的坐标空间
(0,1)               (1,1)


  T      Texture



(0,0)       S       (1,0)

大多数计算机图像都有一个默认的方向
        |
        |
        |
      Y |
        |
        |
        V   ————————————>
                 x
在标准opengl es 20中，纹理不必是正方形，但是每个维度都应该是2的幂，如128,256,512



































































